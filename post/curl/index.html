<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>curl | Raz1ner</title>
  <link rel="shortcut icon" href="https://dev-coco.github.io/favicon.ico?v=1666270487683">
  <link rel="stylesheet" href="https://dev-coco.github.io/styles/main.css">
  <script src="https://dev-coco.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script data-ad-client="ca-pub-6960947409660270" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
  <div class="main">
    <div class="header">
      <div class="nav">
        <div class="logo">
          <a href="https://dev-coco.github.io">
            <img class="avatar" src="https://dev-coco.github.io/images/avatar.png?v=1666270487683" alt="">
          </a>
          <div class="site-title">
            <h1>Raz1ner</h1>
          </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
          <ul>
            <li>
              <a href="/" class="menu">首页</a>
            </li>
            <li>
              <a href="/Featured-Software.html" class="menu">软件</a>
            </li>
            <li>
              <a href="/Online-Tools" class="menu">在线工具</a>
            </li>
            <li>
              <a href="/post/Linux-Command" class="menu">Linux命令</a>
            </li>
            <li>
              <a href="/Excel" class="menu">Excel教程</a>
            </li>
            <li>
              <a href="/post/Terms-and-Privacy" class="menu">隐私与条款</a>
            </li>
          </ul>
        </div>
        <form id="gridea-search-form" action="https://dev-coco.github.io/search/" class="search">
          <input type="search" name="q" class="search-box">
          <span class="search-button">
            <span class="search-icon"></span>
          </span>
        </form>
      </div>
    </div>
    <script>
      document.getElementsByClassName('search-button')[0].addEventListener('click', function () {
        document.getElementById('gridea-search-form').classList.toggle('open');
      })
    </script>

    <div id="main-content" class="post-detail main-container">
      <!-- left -->
      <div id="content" class="main-container-left">
        <article class="post i-card">
        <h2 class="post-title">curl</h2>
        <div class="post-info">
          <time class="post-time">2022-02-01 / 14 min read</time>
            <a href="https://dev-coco.github.io/tag/linux-command/" class="post-tag i-tag i-tag-success">#Linux命令</a>
        </div>
          <div class="post-content">
            <p>利用 URL 规则在命令行下工作的文件传输工具。</p>
<!-- more -->
<h2 id="补充说明">补充说明</h2>
<p>curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl 可以祝一臂之力。</p>
<h2 id="语法">语法</h2>
<pre><code class="language-Shell">curl (选项) (参数)
</code></pre>
<h2 id="选项">选项</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a/--append</td>
<td>上传文件时，附加到目标文件</td>
</tr>
<tr>
<td>-A/--user-agent</td>
<td>设置用户代理发送给服务器</td>
</tr>
<tr>
<td>-anyauth</td>
<td>可以使用“任何”身份验证方法</td>
</tr>
<tr>
<td>-b/--cookie</td>
<td>cookie字符串或文件读取位置</td>
</tr>
<tr>
<td>--basic</td>
<td>使用HTTP基本验证</td>
</tr>
<tr>
<td>-B/--use-ascii</td>
<td>使用ASCII /文本传输</td>
</tr>
<tr>
<td>-c/--cookie-jar</td>
<td>操作结束后把cookie写入到这个文件中</td>
</tr>
<tr>
<td>-C/--continue-at</td>
<td>断点续传</td>
</tr>
<tr>
<td>-d/--data</td>
<td>HTTP POST方式传送数据</td>
</tr>
<tr>
<td>--data-ascii</td>
<td>以ascii的方式post数据</td>
</tr>
<tr>
<td>--data-binary</td>
<td>以二进制的方式post数据</td>
</tr>
<tr>
<td>--negotiate</td>
<td>使用HTTP身份验证</td>
</tr>
<tr>
<td>--digest</td>
<td>使用数字身份验证</td>
</tr>
<tr>
<td>--disable-eprt</td>
<td>禁止使用EPRT或LPRT</td>
</tr>
<tr>
<td>--disable-epsv</td>
<td>禁止使用EPSV</td>
</tr>
<tr>
<td>-D/--dump-header</td>
<td>把header信息写入到该文件中</td>
</tr>
<tr>
<td>--egd-file</td>
<td>为随机数据(SSL)设置EGD socket路径</td>
</tr>
<tr>
<td>--tcp-nodelay</td>
<td>使用TCP_NODELAY选项</td>
</tr>
<tr>
<td>-e/--referer</td>
<td>来源网址</td>
</tr>
<tr>
<td>-E/--cert</td>
<td>客户端证书文件和密码 (SSL)</td>
</tr>
<tr>
<td>--cert-type</td>
<td>证书文件类型 (DER/PEM/ENG) (SSL)</td>
</tr>
<tr>
<td>--key</td>
<td>私钥文件名 (SSL)</td>
</tr>
<tr>
<td>--key-type</td>
<td>私钥文件类型 (DER/PEM/ENG) (SSL)</td>
</tr>
<tr>
<td>--pass</td>
<td>私钥密码 (SSL)</td>
</tr>
<tr>
<td>--engine</td>
<td>加密引擎使用 (SSL). &quot;--engine list&quot; for list</td>
</tr>
<tr>
<td>--cacert</td>
<td>CA证书 (SSL)</td>
</tr>
<tr>
<td>--capath</td>
<td>CA目录 (made using c_rehash) to verify peer against (SSL)</td>
</tr>
<tr>
<td>--ciphers</td>
<td>SSL密码</td>
</tr>
<tr>
<td>--compressed</td>
<td>要求返回是压缩的形势 (using deflate or gzip)</td>
</tr>
<tr>
<td>--connect-timeout</td>
<td>设置最大请求时间</td>
</tr>
<tr>
<td>--create-dirs</td>
<td>建立本地目录的目录层次结构</td>
</tr>
<tr>
<td>--crlf</td>
<td>上传是把LF转变成CRLF</td>
</tr>
<tr>
<td>-f/--fail</td>
<td>连接失败时不显示http错误</td>
</tr>
<tr>
<td>--ftp-create-dirs</td>
<td>如果远程目录不存在，创建远程目录</td>
</tr>
<tr>
<td>--ftp-method [multicwd/nocwd/singlecwd]</td>
<td>控制CWD的使用</td>
</tr>
<tr>
<td>--ftp-pasv</td>
<td>使用 PASV/EPSV 代替端口</td>
</tr>
<tr>
<td>--ftp-skip-pasv-ip</td>
<td>使用PASV的时候,忽略该IP地址</td>
</tr>
<tr>
<td>--ftp-ssl</td>
<td>尝试用 SSL/TLS 来进行ftp数据传输</td>
</tr>
<tr>
<td>--ftp-ssl-reqd</td>
<td>要求用 SSL/TLS 来进行ftp数据传输</td>
</tr>
<tr>
<td>-F/--form</td>
<td>模拟http表单提交数据</td>
</tr>
<tr>
<td>--form-string</td>
<td>模拟http表单提交数据</td>
</tr>
<tr>
<td>-g/--globoff</td>
<td>禁用网址序列和范围使用{}和[]</td>
</tr>
<tr>
<td>-G/--get</td>
<td>以get的方式来发送数据</td>
</tr>
<tr>
<td>-H/--header</td>
<td>自定义头信息传递给服务器</td>
</tr>
<tr>
<td>--ignore-content-length</td>
<td>忽略的HTTP头信息的长度</td>
</tr>
<tr>
<td>-i/--include</td>
<td>输出时包括protocol头信息</td>
</tr>
<tr>
<td>-I/--head</td>
<td>只显示请求头信息</td>
</tr>
<tr>
<td>-j/--junk-session-cookies</td>
<td>读取文件进忽略session cookie</td>
</tr>
<tr>
<td>--interface</td>
<td>使用指定网络接口/地址</td>
</tr>
<tr>
<td>--krb4</td>
<td>使用指定安全级别的krb4</td>
</tr>
<tr>
<td>-k/--insecure</td>
<td>允许不使用证书到SSL站点</td>
</tr>
<tr>
<td>-K/--config</td>
<td>指定的配置文件读取</td>
</tr>
<tr>
<td>-l/--list-only</td>
<td>列出ftp目录下的文件名称</td>
</tr>
<tr>
<td>--limit-rate</td>
<td>设置传输速度</td>
</tr>
<tr>
<td>--local-port</td>
<td>强制使用本地端口号</td>
</tr>
<tr>
<td>-m/--max-time</td>
<td>设置最大传输时间</td>
</tr>
<tr>
<td>--max-redirs</td>
<td>设置最大读取的目录数</td>
</tr>
<tr>
<td>--max-filesize</td>
<td>设置最大下载的文件总量</td>
</tr>
<tr>
<td>-M/--manual</td>
<td>显示全手动</td>
</tr>
<tr>
<td>-n/--netrc</td>
<td>从netrc文件中读取用户名和密码</td>
</tr>
<tr>
<td>--netrc-optional</td>
<td>使用 .netrc 或者 URL来覆盖-n</td>
</tr>
<tr>
<td>--ntlm</td>
<td>使用 HTTP NTLM 身份验证</td>
</tr>
<tr>
<td>-N/--no-buffer</td>
<td>禁用缓冲输出</td>
</tr>
<tr>
<td>-o/--output</td>
<td>把输出写到该文件中</td>
</tr>
<tr>
<td>-O/--remote-name</td>
<td>把输出写到该文件中，保留远程文件的文件名</td>
</tr>
<tr>
<td>-p/--proxytunnel</td>
<td>使用HTTP代理</td>
</tr>
<tr>
<td>--proxy-anyauth</td>
<td>选择任一代理身份验证方法</td>
</tr>
<tr>
<td>--proxy-basic</td>
<td>在代理上使用基本身份验证</td>
</tr>
<tr>
<td>--proxy-digest</td>
<td>在代理上使用数字身份验证</td>
</tr>
<tr>
<td>--proxy-ntlm</td>
<td>在代理上使用ntlm身份验证</td>
</tr>
<tr>
<td>-P/--ftp-port</td>
<td>使用端口地址，而不是使用PASV</td>
</tr>
<tr>
<td>-q</td>
<td>作为第一个参数，关闭 .curlrc</td>
</tr>
<tr>
<td>-Q/--quote</td>
<td>文件传输前，发送命令到服务器</td>
</tr>
<tr>
<td>-r/--range</td>
<td>检索来自HTTP/1.1或FTP服务器字节范围</td>
</tr>
<tr>
<td>--range-file</td>
<td>读取（SSL）的随机文件</td>
</tr>
<tr>
<td>-R/--remote-time</td>
<td>在本地生成文件时，保留远程文件时间</td>
</tr>
<tr>
<td>--retry</td>
<td>传输出现问题时，重试的次数</td>
</tr>
<tr>
<td>--retry-delay</td>
<td>传输出现问题时，设置重试间隔时间</td>
</tr>
<tr>
<td>--retry-max-time</td>
<td>传输出现问题时，设置最大重试时间</td>
</tr>
<tr>
<td>-s/--silent</td>
<td>静默模式。不输出任何东西</td>
</tr>
<tr>
<td>-S/--show-error</td>
<td>显示错误</td>
</tr>
<tr>
<td>--socks4</td>
<td>用socks4代理给定主机和端口</td>
</tr>
<tr>
<td>--socks5</td>
<td>用socks5代理给定主机和端口</td>
</tr>
<tr>
<td>--stderr</td>
<td></td>
</tr>
<tr>
<td>-t/--telnet-option</td>
<td>Telnet选项设置</td>
</tr>
<tr>
<td>--trace</td>
<td>对指定文件进行debug</td>
</tr>
<tr>
<td>--trace-ascii</td>
<td>Like --跟踪但没有hex输出</td>
</tr>
<tr>
<td>--trace-time</td>
<td>跟踪/详细输出时，添加时间戳</td>
</tr>
<tr>
<td>-T/--upload-file</td>
<td>上传文件</td>
</tr>
<tr>
<td>--url</td>
<td>Spet URL to work with</td>
</tr>
<tr>
<td>-u/--user</td>
<td>设置服务器的用户和密码</td>
</tr>
<tr>
<td>-U/--proxy-user</td>
<td>设置代理用户名和密码</td>
</tr>
<tr>
<td>-w/--write-out [format]</td>
<td>什么输出完成后</td>
</tr>
<tr>
<td>-x/--proxy</td>
<td>在给定的端口上使用HTTP代理</td>
</tr>
<tr>
<td>-X/--request</td>
<td>指定什么命令</td>
</tr>
<tr>
<td>-y/--speed-time</td>
<td>放弃限速所要的时间，默认为30</td>
</tr>
<tr>
<td>-Y/--speed-limit</td>
<td>停止传输速度的限制，速度时间</td>
</tr>
</tbody>
</table>
<h2 id="实例">实例</h2>
<h3 id="文件下载">文件下载</h3>
<p>curl 命令可以用来执行下载、发送各种 HTTP 请求，指定 HTTP 头部等操作。如果系统没有 curl 可以使用<code>yum install curl</code>安装，也可以下载安装。curl 是将下载文件输出到 stdout，将进度信息输出到<code>stderr</code>，不显示进度信息使用<code>--silent</code>选项。</p>
<pre><code class="language-Shell">curl URL --silent
</code></pre>
<p>这条命令是将下载文件输出到终端，所有下载的数据都被写入到 stdout。<br>
使用选项<code>-O</code>将下载的数据写入到文件，必须使用文件的绝对地址：</p>
<pre><code class="language-Shell">curl http://example.com/text.iso --silent -O
</code></pre>
<p>选项<code>-o</code>将下载数据写入到指定名称的文件中，并使用<code>--progress</code>显示进度条：</p>
<pre><code class="language-Shell">curl http://example.com/test.iso -o filename.iso --progress
######################################### 100.0%
</code></pre>
<h3 id="不输出错误和进度信息">不输出错误和进度信息</h3>
<p><code>-s</code>参数将不输出错误和进度信息。</p>
<pre><code class="language-Shell">curl -s https://www.example.com
# 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。
</code></pre>
<p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p>
<pre><code class="language-Shell">curl -s -o /dev/null https://google.com
</code></pre>
<h3 id="断点续传">断点续传</h3>
<p>curl 能够从特定的文件偏移处继续下载，它可以通过指定一个便宜量来下载部分文件：</p>
<pre><code class="language-Shell">curl URL/File -C 偏移量

#偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：
curl -C -URL
</code></pre>
<h3 id="使用-curl-设置参照页字符串">使用 curl 设置参照页字符串</h3>
<p>参照页是位于 HTTP 头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页 A中的某个连接，那么用户就会跳转到B网页，网页B头部的参照页字符串就包含网页 A 的 URL。<br>
使用<code>--referer</code>选项指定参照页字符串：</p>
<pre><code class="language-Shell">curl --referer http://www.google.com http://example.com
</code></pre>
<h3 id="用curl设置用户代理字符串">用curl设置用户代理字符串</h3>
<p>有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用 curl 把用户代理设置为 IE，这样就可以访问了。使用<code>--user-agent</code>或者<code>-A</code>选项：</p>
<pre><code class="language-Shell">curl URL --user-agent &quot;Mozilla/5.0&quot;
curl URL -A &quot;Mozilla/5.0&quot;
</code></pre>
<p>其他 HTTP 头部信息也可以使用 curl 来发送，使用<code>-H</code>&quot;头部信息&quot; 传递多个头部信息，例如：</p>
<pre><code class="language-Shell">curl -H &quot;Host:example.com&quot; -H &quot;accept-language:zh-cn&quot; URL
</code></pre>
<h3 id="curl-的带宽控制和下载配额">curl 的带宽控制和下载配额</h3>
<p>使用<code>--limit-rate</code>限制 curl 的下载速度：</p>
<pre><code class="language-Shell">curl URL --limit-rate 50k
</code></pre>
<p>命令中用 k（千字节）和 m（兆字节）指定下载速度限制。<br>
使用<code>--max-filesize</code>指定可下载的最大文件大小：</p>
<pre><code class="language-Shell">curl URL --max-filesize bytes
</code></pre>
<p>如果文件大小超出限制，命令则返回一个非 0 退出码，如果命令正常则返回 0。</p>
<pre><code class="language-Shell">curl --limit-rate 200k https://example.com
# 上面命令将带宽限制在每秒 200K 字节。
</code></pre>
<h3 id="用-curl-进行认证">用 curl 进行认证</h3>
<p>使用 curl 选项 -u 可以完成 HTTP 或者 FTP 的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：</p>
<pre><code class="language-Shell">curl -u user:pwd http://example.com
curl -u user http://example.com
</code></pre>
<h3 id="只打印响应头部信息">只打印响应头部信息</h3>
<p>通过 -I 或者 -head 可以只打印出 HTTP 头部信息：</p>
<pre><code class="language-Shell">[root@localhost text]# curl -I http://example.com
HTTP/1.1 200 OK
Server: nginx/1.2.5
date: Mon, 10 Dec 2012 09:24:34 GMT
Content-Type: text/html; charset=UTF-8
Connection: keep-alive
Vary: Accept-Encoding
X-Pingback: http://example.com/xmlrpc.php
</code></pre>
<h3 id="get-请求">get 请求</h3>
<pre><code class="language-Shell">curl &quot;http://www.example.com&quot;    # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地
curl -i &quot;http://www.example.com&quot; # 显示全部信息
curl -l &quot;http://www.example.com&quot; # 只显示头部信息
curl -v &quot;http://www.example.com&quot; # 显示get请求全过程解析
</code></pre>
<h3 id="post-请求">post 请求</h3>
<pre><code class="language-Shell">$ curl -d &quot;param1=value1&amp;param2=value2&quot; &quot;http://www.example.com/login&quot;

curl -d'login=emma＆password=123' -X POST https://example.com/login
# 或者
$ curl -d 'login=emma' -d 'password=123' -X POST  https://example.com/login
</code></pre>
<p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送<code>POST</code>请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p>
<pre><code class="language-Shell">curl --data-urlencode 'comment=hello world' https://example.com/login
# 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。
</code></pre>
<p>读取本地文本文件的数据，向服务器发送</p>
<pre><code class="language-Shell">curl -d '@data.txt' https://example.com/upload
# 读取data.txt文件的内容，作为数据体向服务器发送。
</code></pre>
<h3 id="json-格式的-post-请求">json 格式的 post 请求</h3>
<pre><code class="language-Shell">curl -l -H &quot;Content-type: application/json&quot; -X POST -d '{&quot;phone&quot;:&quot;13521389587&quot;,&quot;password&quot;:&quot;test&quot;}' http://example.com/apis/users.json
</code></pre>
<h3 id="向服务器发送-cookie">向服务器发送 Cookie</h3>
<p>使用<code>--cookie &quot;COKKIES&quot;</code>选项来指定 cookie，多个 cookie 使用分号分隔：</p>
<pre><code class="language-Shell">curl http://example.com --cookie &quot;user=root;pass=123456&quot;
</code></pre>
<p>将 cookie 另存为一个文件，使用<code>--cookie-jar</code>选项：</p>
<pre><code class="language-Shell">curl URL --cookie-jar cookie_file
</code></pre>
<p><code>-b</code>参数用来向服务器发送 Cookie。</p>
<pre><code class="language-Shell">curl -b 'foo=bar' https://example.com
# 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。
</code></pre>
<pre><code class="language-Shell">curl -b 'foo1=bar' -b 'foo2=baz' https://example.com
# 上面命令发送两个 Cookie。

```shell
curl -b cookies.txt https://www.example.com
# 上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。
</code></pre>
<h3 id="cookie-写入一个文件">Cookie 写入一个文件</h3>
<pre><code class="language-Shell">curl -c cookies.txt https://www.example.com
# 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。
</code></pre>
<h3 id="请求的来源">请求的来源</h3>
<p><code>-e</code>参数用来设置<code>HTTP</code>的标头`Referer，表示请求的来源。</p>
<pre><code class="language-Shell">curl -e 'https://example.com?q=example' https://www.example.com
# 上面命令将Referer标头设为 https://example.com?q=example。
</code></pre>
<p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p>
<pre><code class="language-Shell">curl -H 'Referer: https://example.com?q=example' https://www.example.com
</code></pre>
<h3 id="上传二进制文件">上传二进制文件</h3>
<p><code>-F</code>参数用来向服务器上传二进制文件。</p>
<pre><code class="language-Shell">curl -F 'file=@photo.png' https://example.com/profile
# 上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data ，然后将文件photo.png作为file字段上传。
</code></pre>
<p><code>-F</code>参数可以指定<code>MIME</code>类型。</p>
<pre><code class="language-Shell">curl -F 'file=@photo.png;type=image/png' https://example.com/profile
# 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。
</code></pre>
<p><code>-F</code>参数也可以指定文件名。</p>
<pre><code class="language-Shell">curl -F 'file=@photo.png;filename=me.png' https://example.com/profile
# 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。
</code></pre>
<h2 id="设置请求头">设置请求头</h2>
<p><code>-H</code>参数添加<code>HTTP</code>请求的标头。</p>
<pre><code class="language-Shell">curl -H 'Accept-Language: en-US' https://google.com
# 上面命令添加 HTTP 标头 Accept-Language: en-US。
</code></pre>
<pre><code class="language-Shell">curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com
# 上面命令添加两个 HTTP 标头。
</code></pre>
<pre><code class="language-Shell">curl -d '{&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;}' -H 'Content-Type: application/json' https://google.com/login
# 上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用 -d 参数发送 JSON 数据。
</code></pre>
<h3 id="跳过-ssl-检测">跳过 SSL 检测</h3>
<pre><code class="language-Shell">curl -k https://www.example.com
# 上面命令不会检查服务器的 SSL 证书是否正确。
</code></pre>
<h3 id="请求跟随服务器的重定向">请求跟随服务器的重定向</h3>
<p><code>-L</code>参数会让<code>HTTP</code>请求跟随服务器的重定向。<code>curl</code>默认不跟随重定向。</p>
<pre><code class="language-Shell">curl -L -d 'tweet=hi' https://api.example.com/tweet
</code></pre>
<h3 id="调试参数">调试参数</h3>
<p><code>-v</code>参数输出通信的整个过程，用于调试。</p>
<pre><code class="language-Shell">curl -v https://www.example.com
# --trace参数也可以用于调试，还会输出原始的二进制数据。
</code></pre>
<pre><code class="language-Shell">$ curl --trace - https://www.example.com
</code></pre>
<h3 id="获取本机外网ip">获取本机外网ip</h3>
<pre><code class="language-Shell">curl ipecho.net/plain
</code></pre>

          </div>
        </article>
        <div class="next-post">
          <div class="next">下一篇</div>
          <a href="https://dev-coco.github.io/post/cupsenable/">
            <h3 class="post-title">cupsenable</h3>
          </a>
        </div>
        <div id="disqus_thread"></div>
        <div id="gitalk-container"></div>
      </div>
      <!-- middle -->
      <div class="main-container-middle"></div>
      <!-- right -->
      <div id="sidebar" class="main-container-right">
        <div class="id_card i-card">
          <div class="id_card-avatar" style="background-image: url(https://dev-coco.github.io/images/avatar.png?v=1666270487683)"></div>
          <h1 class="id_card-title">Raz1ner</h1>
          <img style="margin-top: 15px;margin-bottom: 10px;" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fdev-coco.github.io&amp;count_bg=%2310C1F9&amp;title_bg=%23555555&amp;icon=html5.svg&amp;icon_color=%23E7E7E7&amp;title=%E8%AE%BF%E9%97%AE%E4%BA%BA%E6%95%B0&amp;edge_flat=false">
          <p style="text-align: center;">
            <a href="https://github.com/dev-coco" target="_blank"><img class="social-icon" src="/images/social/GitHub.png"></a>
            <a href="https://t.me/raz1ner" target="_blank"><img class="social-icon" src="/images/social/Telegram.png"></a>
            <a href="https://www.youtube.com/channel/UCEgNinV_DEntuv5Dm8Z_JvA?sub_confirmation=1" target="_blank"><img class="social-icon" src="/images/social/YouTube.png"></a>
            <a href="/atom.xml" target="_blank"><img class="social-icon" src="/images/social/RSS.png"></a>
            <a href="mailto:ruijingle@gmail.com" target="_blank"><img class="social-icon" src="/images/social/Gmail.png"></a>
          </p>
          <!-- <h2 class="id_card-description"></h2> -->
          <!--  -->
          <div class="id_card-sns">
            <!-- github -->
            
            <!-- twitter -->
            <!-- weibo -->
            <!-- facebook -->
          </div>
        </div>
      <!-- toc -->
      <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
          <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">补充说明</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a href="#%E9%80%89%E9%A1%B9">选项</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B">实例</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">文件下载</a></li>
<li><a href="#%E4%B8%8D%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF%E5%92%8C%E8%BF%9B%E5%BA%A6%E4%BF%A1%E6%81%AF">不输出错误和进度信息</a></li>
<li><a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-curl-%E8%AE%BE%E7%BD%AE%E5%8F%82%E7%85%A7%E9%A1%B5%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 curl 设置参照页字符串</a></li>
<li><a href="#%E7%94%A8curl%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2">用curl设置用户代理字符串</a></li>
<li><a href="#curl-%E7%9A%84%E5%B8%A6%E5%AE%BD%E6%8E%A7%E5%88%B6%E5%92%8C%E4%B8%8B%E8%BD%BD%E9%85%8D%E9%A2%9D">curl 的带宽控制和下载配额</a></li>
<li><a href="#%E7%94%A8-curl-%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81">用 curl 进行认证</a></li>
<li><a href="#%E5%8F%AA%E6%89%93%E5%8D%B0%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF">只打印响应头部信息</a></li>
<li><a href="#get-%E8%AF%B7%E6%B1%82">get 请求</a></li>
<li><a href="#post-%E8%AF%B7%E6%B1%82">post 请求</a></li>
<li><a href="#json-%E6%A0%BC%E5%BC%8F%E7%9A%84-post-%E8%AF%B7%E6%B1%82">json 格式的 post 请求</a></li>
<li><a href="#%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81-cookie">向服务器发送 Cookie</a></li>
<li><a href="#cookie-%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6">Cookie 写入一个文件</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90">请求的来源</a></li>
<li><a href="#%E4%B8%8A%E4%BC%A0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6">上传二进制文件</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4">设置请求头</a>
<ul>
<li><a href="#%E8%B7%B3%E8%BF%87-ssl-%E6%A3%80%E6%B5%8B">跳过 SSL 检测</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%B7%9F%E9%9A%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">请求跟随服务器的重定向</a></li>
<li><a href="#%E8%B0%83%E8%AF%95%E5%8F%82%E6%95%B0">调试参数</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%A4%96%E7%BD%91ip">获取本机外网ip</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
          <script>
            function locateCatelogList() {
              /*获取文章目录集合,可通过:header过滤器*/
              var alis = $('.post-content :header');
              /*获取侧边栏目录列表集合**/
              var sidebar_alis = $('.markdownIt-TOC a');
              /*获取滚动条到顶部的距离*/
              var scroll_height = $(window).scrollTop();
              for (var i = 0; i < alis.length; i++) {
                /*获取锚点集合中的元素分别到顶点的距离*/
                var a_height = $(alis[i]).offset().top;
                if (a_height < scroll_height) {
                  /*高亮显示*/
                  sidebar_alis.removeClass('on');
                  $(sidebar_alis[i]).addClass('on');
                }
              }
            }
            $(function() {
              /*绑定滚动事件 */
              $(window).bind('scroll', locateCatelogList);
              });
          </script>
        </div>
      <div class="notice-card i-card ">
        <div class="notice-title i-card-title">公告</div>
        <div class="notice-content">博客新开通 Telegram 频道：<a href="https://t.me/raz1ner" target="_blank" style="color: blue">瑞景乐的博客</a>，欢迎订阅，随时收到最新资讯。<br>商务合作请点击上方的邮箱与我联系。</div>
      </div>
      <div class="notice-card i-card "><div class="notice-title i-card-title"><a href="/tags/">标签</a></div>
        <div class="notice-content">
          <a class="tags-tag i-tag i-tag-other_1" href="https://dev-coco.github.io/tag/sololearn/">Sololearn</a>
          <a class="tags-tag i-tag i-tag-" href="https://dev-coco.github.io/tag/macos/">macOS</a>
          <a class="tags-tag i-tag i-tag-primary" href="https://dev-coco.github.io/tag/google-script/">Google 脚本</a>
          <a class="tags-tag i-tag i-tag-banana" href="https://dev-coco.github.io/tag/other/">其它</a>
          <a class="tags-tag i-tag i-tag-other_1" href="https://dev-coco.github.io/tag/whatsapp/">WhatsApp</a>
          <a class="tags-tag i-tag i-tag-banana" href="https://dev-coco.github.io/tag/facebook/">Facebook</a>
          <a class="tags-tag i-tag i-tag-warning" href="https://dev-coco.github.io/tag/shell/">Shell</a>
          <a class="tags-tag i-tag i-tag-info" href="https://dev-coco.github.io/tag/software/">软件</a>
          <a class="tags-tag i-tag i-tag-banana" href="https://dev-coco.github.io/tag/security/">安全</a>
          <a class="tags-tag i-tag i-tag-other_3" href="https://dev-coco.github.io/tag/excel/">Excel</a>
          <a class="tags-tag i-tag i-tag-info" href="https://dev-coco.github.io/tag/javascript/">Javascript</a>
          <a class="tags-tag i-tag i-tag-banana" href="https://dev-coco.github.io/tag/windows/">Windows</a>
          <a class="tags-tag i-tag i-tag-other_3" href="https://dev-coco.github.io/tag/ios/">iOS</a>
          <a class="tags-tag i-tag i-tag-info" href="https://dev-coco.github.io/tag/linux-command/">Linux命令</a>
        </div>
      </div>
      </div>
    </div>
    <div class="site-footer">
    <span>Copyright © 2020-2022 Raz1ner - All Rights Reserved.</span> | <a class="rss" href="https://dev-coco.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
  <script>
    $('#sidebar').stickySidebar({
    topSpacing: 80,
    // bottomSpacing: 60
    });
  </script>
  
</body>
</html>